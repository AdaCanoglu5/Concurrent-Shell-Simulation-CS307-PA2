# Concurrent-Shell-simulation-in-C
In this project i have created a Shell simulator that reads multiple Linux commands from a file and executes them concurrently using multiple threads and processes that communicate via piped file descriptors. Synchronization is achieved with the usage of piped file descriptors and mutexes for threads.

Detailed information on the work flow of the program:

In the implementation, first “commands.txt” is opened and every line in the file is read by using “fgets” inside a while loop. Some variables are created inside the while loop to keep the information about the command that is being read, such as whether it is a background job or not. Each line is divided by into parts with each space between, using “strtok” in c. Arguments that will be sent to “execvp” are inserted into an array and rest of the information in the line are kept inside variables. After parsing is done, shell checks whether command is “wait” or not, if it is wait then wait function is called and skips the forking, more on the wait function later. A pipe is then dynamically allocated before calling the fork(), to easily manage the pipes. After the fork() call, inside the newly created child process, it is checked whether or not there is a redirection, that is if the command wants to read from or write to a file. If there is a file that will be read, child process opens the file in read before calling the “execvp”. If there is a file that will be written onto, the child process opens the file in write before calling the “execvp”. Before calling the “execvp”, except for the case to write to a file, child process writes to the piped file descriptor that was created before the forking, using the dup2 function. All file descriptors are closed appropriately during all these steps. Inside the shell process after the forking, the id of the newly created process is than inserted inside a global array that keeps the ids of all the created process alongside the count of the processes that are created which will be used when calling the wait function. Inside the shell process if there is no writing to a file, a thread is created for the new child process, which runs the function named “threadFunction” and takes the piped file descriptor as it’s parameter. The ids and count of the threads are also kept inside a global array and an integer just like the processes. The reason why threads are used is to synchronize the writing to the console and keep the concurrency inside the shell process, so that shell can keep parsing more lines and write to the console concurrently. After creating the thread, the shell function waits for the specific process to end using its id if the said process is not a background job. After that, the shell process writes the details about the command that was parsed into the “parse.txt” file, before parsing the next line in the loop. All the commands in the “commands.txt” file are then parsed and executed concurrently until the loop ends. After the loop ends, the shell process calls the wait function which then waits for all process to end and all threads to join before the shell process terminates. 

Inside the “threadFunction”, a global variable mutex is used from the standard c library. The mutex is used so that while threads are writing to the console, the outputs would not get mixed up as we created threads to avoid this problem. Inside the function the thread first writes its id and then reads from the pipe that was inputted into the function. The thread then writes every line to the console that is read from the pipe inside a while loop. Thread then prints its id again after writing the output. “fflush” is used for all the writing to the console in the thread for the effects of the print statements to be immediately visible on the console. The dynamically allocated piped file descriptor is then deleted using the free() in c, since the specific file descriptor is no longer needed.

Inside the “waitFunction”, all of the threads inside the global variable array for keeping the thread ids are joined inside a for loop according to the count of the threads. This array is then reset by initializing the elements in the array to 0 and changing thread count to 0. Same procedure is then made for the processes as well, that is waitpid() function is used inside a for loop for every process id inside the array for keeping the process ids. Process id array and count is then reset, just like the thread array and count. After calling the “waitFunction” all the running processes will be waited and threads will be joined.
